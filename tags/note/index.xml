<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>note on Linro</title>
    <link>https://blog.linyxus.xyz/tags/note/</link>
    <description>Recent content in note on Linro</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Fri, 10 May 2019 13:12:24 +0800</lastBuildDate><atom:link href="https://blog.linyxus.xyz/tags/note/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>物理实验数据处理公式总结</title>
      <link>https://blog.linyxus.xyz/posts/physics-experiements-formula/</link>
      <pubDate>Fri, 10 May 2019 13:12:24 +0800</pubDate>
      
      <guid>https://blog.linyxus.xyz/posts/physics-experiements-formula/</guid>
      <description>贝塞尔公式 s(x) = √((⎲⎳(xi − x)2)/(n − 1))  s(x) = (s(x))/(√(n)) = √((⎲⎳(xi − x)2)/(n(n − 1)))   直接测量量不确定度 当 n = 6 时，
ua(x) = tps(x) = s(x)  且有
ub(x) = Δ仪  合成不确定度：
u(x) = √(u2a(x) + u2b(x))   间接测量量不确定度 全微分 -&amp;gt; 绝对 取对数后全微分 -&amp;gt; 相对   误差等分配原则 也即合成不确定度中各平方项相等。
 最小二乘法 如果设：
y = kx + b  可以求解出：
k  = (xy − xy)/(x2 − x2)      b  = y − kx     相关系数：</description>
    </item>
    
    <item>
      <title>Calculus Cheatsheets :: 级数</title>
      <link>https://blog.linyxus.xyz/posts/calculus-cheatsheet-series/</link>
      <pubDate>Thu, 02 May 2019 19:09:04 +0800</pubDate>
      
      <guid>https://blog.linyxus.xyz/posts/calculus-cheatsheet-series/</guid>
      <description>常数项级数 概念 定义 各项均为常数的级数
 部分和 σ(n) = n⎲⎳k = 0ak   敛散性 若
limn → ∞σ(n) = A存在  则称级数收敛于 A 。
否则称级数发散。
  收敛级数性质 线性性质 归并性质   正项级数审敛法 比较审敛法 yn ≤ xn∧xn收敛 ⇒ yn收敛     yn ≥ xn∧xn发散 ⇒ yn发散     极限形式：
limn → ∞(an)/(bn) = + ∞ ⇒ bn发散则an发散     limn → ∞(an)/(bn) = 0 ⇒ an收敛则bn收敛     limn → ∞(an)/(bn) = k(k &amp;gt; 0) ⇒ an, bn同时敛散      比值审敛法 limn → ∞(an + 1)/(an) = K  若 K &amp;lt; 1 则 an 收敛 若 K &amp;gt; 1 则 an 发散 若 K = 1 则 an 敛散性未知   根式审敛法 limn → ∞n√(an) = λ  情况可类比比值审敛法。</description>
    </item>
    
    <item>
      <title>离散数学复习笔记 :: 逻辑学</title>
      <link>https://blog.linyxus.xyz/posts/discrete-math-notes-logic/</link>
      <pubDate>Mon, 22 Apr 2019 19:09:35 +0800</pubDate>
      
      <guid>https://blog.linyxus.xyz/posts/discrete-math-notes-logic/</guid>
      <description>Proposition Logic Basics What is a proposition A statement of proposition is a declarative sentence that is either true or false, but not both.
The moon is made of green cheese: &amp;nbsp;a proposition  Go to town!:not a proposition  What time is it?: &amp;nbsp;not a proposition     Build up a proposition propostional variables logical connectives   Kinds of logical connectives Negation &#39;NOT&#39; :: ¬
 Conjunction &#39;AND&#39; :: ∧</description>
    </item>
    
    <item>
      <title>Physics Lifesaving Notes :: 质点运动学基础</title>
      <link>https://blog.linyxus.xyz/posts/physics-lifesaving-notes-1/</link>
      <pubDate>Thu, 18 Apr 2019 20:37:30 +0800</pubDate>
      
      <guid>https://blog.linyxus.xyz/posts/physics-lifesaving-notes-1/</guid>
      <description>基本概念 质点:大小、形状可以忽略的物体  质点系:多个质点的组合     基本参数 位置矢量 r⃗ = xi⃗ + yj⃗ + zk⃗   运动方程 r⃗ = r⃗(t)   轨迹方程 将运动方程中的 t 消去即得到轨迹方程。
 位移与路程 位移为始末位置矢量的改变量。
Δr⃗ = r⃗2 − r⃗1  路程为运动轨迹的长度。
位移与路程的关系 位移不等于路程：位移是矢量，路程是标量 limΔt → 0|Δr⃗| = Δs ，也即 |dr| = ds    速度 v⃗ = (dr⃗)/(dt)   加速度 a⃗ = (dv⃗)/(dt)    自然坐标系 已知质点运动的轨迹：
e⃗n 法向单位矢量，指向轨迹曲线 内侧</description>
    </item>
    
    <item>
      <title>电路分析笔记 :: 动态电路分析</title>
      <link>https://blog.linyxus.xyz/posts/circuit-analysis-notes-3/</link>
      <pubDate>Mon, 15 Apr 2019 20:34:15 +0800</pubDate>
      
      <guid>https://blog.linyxus.xyz/posts/circuit-analysis-notes-3/</guid>
      <description>基本元件 电容 动态特性 i = (dq)/(dt) = C(dU)/(dt)   记忆特性 uc = (1)/(C)t0⌠⌡− ∞icdt  也即电压反映了电流的累积效果。
 储能特性 W = (1)/(2)CU2    电感 动态特性 uL = (dφ)/(dt) = L(di)/(dt)   记忆特性 iL = (1)/(L)t0⌠⌡∞uLdt  也即电流反映了电压的累积效果。
 储能特性 W = (1)/(2)Li2    电容、电感的串并联 电容等同于电导。
电感等同于电阻。
  动态响应分析 一阶零输入响应 y(t) = y(0 + )e − (1)/(τ)  一阶RC电路:τ = RC  一阶RL电路:τ = (L)/(R)    R 也即电容电感两端的等效输入电阻。</description>
    </item>
    
    <item>
      <title>电路分析笔记 :: 基本分析方法</title>
      <link>https://blog.linyxus.xyz/posts/circuit-analysis-notes-2/</link>
      <pubDate>Sun, 14 Apr 2019 21:42:06 +0800</pubDate>
      
      <guid>https://blog.linyxus.xyz/posts/circuit-analysis-notes-2/</guid>
      <description>变量分析 基尔霍夫定律 KCL 基尔霍夫电流定律
对任意电路的任意节点，在任意时刻流入该节点的电流代数和为0。
b⎲⎳k = 1ik(t) = 0  若规定流入为正，流出即为负。
推广 广义节点（封闭面）同样成立。
  KVL 对任意集总电路的任意回路，在任意时刻，沿该回路的所有支路的电压降 代数和为0。
b⎲⎳k = 1uk(t) = 0  可以从电路中任意一点的电势为一确定值理解。
  2b法 假设电阻有 n 个节点， b 条支路。根据拓扑约束列出 (n − 1) 个独立电流方程， (b − n + 1) 个独立电压方程。 根据元件约束列出 (b) 个VCR方程。
共计 2b 个方程，求解 b 条支路的 2b 个未知量。
 支路电流法 也即代入VCR元件约束，将电压量代换为电流量。
 节点电压法 形式 ⎧⎪⎪⎨⎪⎪⎩G11u1 + G12u2 + ⋯ + G1nun = is11     G21u1 + G22u2 + ⋯ + G2nun = is22     ⋯     Gn1u1 + Gn2u2 + ⋯ + Gnnun = isnn     其中：</description>
    </item>
    
    <item>
      <title>电路分析笔记 :: 电路分析基础模型</title>
      <link>https://blog.linyxus.xyz/posts/circuit-analysis-notes-1/</link>
      <pubDate>Fri, 12 Apr 2019 20:17:12 +0800</pubDate>
      
      <guid>https://blog.linyxus.xyz/posts/circuit-analysis-notes-1/</guid>
      <description>电路模型基本概念 电路模型:从实际电路中抽象出的模型  激励:输入电路的信号  响应:经过电路加工处理后得到的信号  集总参数元件:当实际电路的尺寸远小于其使用时最高工作频率所对应的波长时而抽象出的理想元件  集总电路模型:又集总参数元件组成的电路  分布参数电路:当实际电路的尺寸大于其最高工作频率所对应的波长或两者属于同一数量级时     电路模型基本变量 电流、电压、功率。
电压与电流的参考方向 由于电路分析中，电压与电流的实际方向很难确定，故可以假设这两个变量的方向，以电流为例。
假设 I 从a流向b，若实际电流方向与参考方向相同
I &amp;gt; 0  否则
I &amp;lt; 0   电压与电流的关联参考方向 若在假定的关联参考方向下，电流 I 从高电势流向低电势，则是关联参考方向。
否则为非关联参考方向。
 电压 p = (dW)/(dt) = (dW)/(dq)⋅(dq)/(dt) = u⋅i  若在非关联参考方向下
p = − u⋅i  p &amp;gt; 0:吸收功率  p &amp;lt; 0:供出功率      电路模型基本原件 电阻 如果一个元件的端电压u和通过的电流i是关联参考方向，其伏安关系是通过原点的曲线，这个元件就是电阻元件。
u, i 为关联参考方向时</description>
    </item>
    
    <item>
      <title>雏雁计划神经网络训练记录</title>
      <link>https://blog.linyxus.xyz/posts/mental-health-nn-training/</link>
      <pubDate>Tue, 09 Apr 2019 15:40:08 +0800</pubDate>
      
      <guid>https://blog.linyxus.xyz/posts/mental-health-nn-training/</guid>
      <description>思路 使用前20个问题预测剩下11个问题的答案。将经常、有时、很少、从不规范化为[1, 0.33, -0.33, -1]。   训练笔记 Small ReLU 20 -&amp;gt; 18 -&amp;gt; 11
Result:
acc 65.22% test_acc 45.45%   Mid Relu 20 -&amp;gt; 30 -&amp;gt; 11
Result:
acc: 0.7521 test_acc: 0.4727 test_acc_l: 0.6636   Tiny Relu 20 -&amp;gt; 10 -&amp;gt; 11
Result:
acc: 0.5513 test_acc: 0.5091 test_acc_l: 0.5509   Smaller Relu 20 -&amp;gt; 15 -&amp;gt; 11
Result:
acc: 0.5853 test_acc: 0.5236 test_acc_l: 0.7909   Smaller Relu V2 Difference: change batch_size to 32, shuffle data.</description>
    </item>
    
    <item>
      <title>Physics Lifesaving Notes :: 静电场中的导体与电介质</title>
      <link>https://blog.linyxus.xyz/posts/physics-lifesaving-notes-0/</link>
      <pubDate>Mon, 08 Apr 2019 19:46:14 +0800</pubDate>
      
      <guid>https://blog.linyxus.xyz/posts/physics-lifesaving-notes-0/</guid>
      <description>静电平衡 导体的定义 具有大量能够自由移动的电子 在外电场的作用下，能够很好的传导电流  的物质。
 静电平衡的条件与特征 条件：  导体内部任意一点的电场强度都为0 导体表面上任意一点的电场强度方向垂直于该出导体表面  除此以外，由于导体内部电场处处为0，由于  E = − (∂V)/(∂l)  因而电势处处相等，导体成为等势体。   静电平衡的理解 与 霍尔效应 有几分类似。导体内部的自由电荷会均衡它收到的电场，内部电荷产生的电场与外加电场抵消， 内部电场处处为0，导体达到静电平衡。   静电平衡时的电荷分布 电荷分布 处于静电平衡状态的导体，内部处处没有净电荷存在，电荷只分布在导体表面上。  证明方法很简单，用高斯定理。  当到体内有空腔时，空腔表面也无电荷。证明如下：  取包围空腔的高斯面，由于电场强度 E 处处为 0，故空腔表面净电荷也为零。假设空腔表面一部分 正电荷，一部分带负电荷，则空腔内存在电场。故而电势沿电场线方向有上升或降落，而静电场为保守场切导体内部处处 等电势，故而矛盾。故不存在电荷。   贴近表面处的电场强度 E = (σ)/(ϵ0)  使用高斯定理证明即可。  值得一提的是，面积元 ΔS 事实上可以等效为无限大带点平面，它对靠近表面的点 P 产生的 场强事实上为  E1 = (σ)/(2ϵ0)  而余下所有电荷在此处产生的场强和为  E2 = (σ)/(2ϵ0)  才有  E = E1 + E2 = (σ)/(ϵ0)  因而导体表面场强事实上为  E’ = E2 = (σ)/(2ϵ0)    静电感应与静电屏蔽 静电感应 导体在外加电场 E0 的影响下，被感应出感应电荷，达到静电平衡状态。  原理为：在电场 E0 的作用下，导体内的电子产生移动，在导体的一面积累而呈现带负电荷，另一面由于 缺少电子而呈现正电荷。  于是导体内产生感应电场 E’ ，当感应电场与外加电场抵消也即 E0 + E’ = 0 时，达到 静电平衡。   静电屏蔽 因此空腔导体具有静电屏蔽作用。  空腔导体内无电荷。 空腔导体内有电荷。  空腔内壁上会被感应出等量异号电荷，因此表面也会产生等量同号电荷。这时将导体外壁接地，则被导体包裹的电荷将不能 对外界产生任何影响。  例题 两块等面积金属板，分别带电荷 qA 和 qB ，平板面积为 S ，两板间距为 d 。且面积线度远大于间距。试求静电平衡时两板各表面上的电荷面密度。 解析 根据电荷守恒与板内电场强度为0列出方程即可求解。</description>
    </item>
    
    <item>
      <title>Note on Pytorch 60-min Blitz</title>
      <link>https://blog.linyxus.xyz/posts/note-on-pytorch-60min-blitz/</link>
      <pubDate>Thu, 04 Apr 2019 22:59:05 +0800</pubDate>
      
      <guid>https://blog.linyxus.xyz/posts/note-on-pytorch-60min-blitz/</guid>
      <description>Tensor Create a tensor via torch.empty  x = torch.empty(5, 3)  This will create a tensor with a size of (5, 3). It is not initialized.  via torch.zero  </description>
    </item>
    
    <item>
      <title>微积分笔记 #1 :: 多元微积分初步</title>
      <link>https://blog.linyxus.xyz/posts/caculas-1/</link>
      <pubDate>Mon, 01 Apr 2019 16:28:15 +0800</pubDate>
      
      <guid>https://blog.linyxus.xyz/posts/caculas-1/</guid>
      <description>n-dimension Euclid Space $R^n$&amp;nbsp;¶ 邻域&amp;nbsp;¶ $$ X_0点的\delta邻域：B(X_0, \delta) = {X \in R^n : ||X-X_0&amp;lt;\delta||} $$
$$ X_0点的去心\delta邻域：B(X_0, \delta) = {X \in R^n : 0 &amp;lt; ||X-X_0|| &amp;lt; \delta} $$
点与集&amp;nbsp;¶ 内点： $$ I(x) : x为\Omega的内点 $$
$$ I(x) \Leftrightarrow \exists \delta &amp;gt; 0, B(x,\delta) \subset \Omega $$
边界点： $$ S(x) \Leftrightarrow \forall \delta &amp;gt; 0 (B(x,\delta) \cap \Omega \neq \emptyset \wedge B(x,\delta) \cap R^n /\Omega \neq \emptyset) $$ 说明点$x$的任意一个邻域都横跨了集合$\Omega$的边界，很漂亮的定义。</description>
    </item>
    
    <item>
      <title>利用cron自动同步org到Github</title>
      <link>https://blog.linyxus.xyz/posts/sync-org-files/</link>
      <pubDate>Tue, 26 Feb 2019 22:58:41 +0800</pubDate>
      
      <guid>https://blog.linyxus.xyz/posts/sync-org-files/</guid>
      <description> 效果&amp;nbsp;¶   每天在固定的时间，只要电脑开着，自动commit发生在org文件夹内的改动，并且push到Github上。
如图，设定的是在所有的整点都会自动更新。
步骤&amp;nbsp;¶ #1 编写自动同步shell&amp;nbsp;¶ #!/bin/bash  echo -e &amp;#34;\033[0;32mPulling from GitHub...\033[0m&amp;#34; git pull git add . git commit -m &amp;#34;Auto update : `date`&amp;#34; echo -e &amp;#34;\033[0;32mPushing to GitHub...\033[0m&amp;#34; git push origin master 在echo的文本里奇奇怪怪的内容都是escape characters，目的是更更改文本的颜色（为绿色）。目的是看起来更加舒服。（可是自动运行的时候你根本看不见啊喂）
#2 增加cron task&amp;nbsp;¶ 在命令行中输入：
$ EDITOR=nano cron -e 增加这一行：
0 * * * * cd ~/org &amp;amp;&amp;amp; ./update.sh 保存退出即可。
 注意！注意！注意！
macOS下由于一些奇怪的权限原因，只能使用Terminal.app进行编辑。
iTerm2是不行的。
 #3 Enjoy it!&amp;nbsp;¶ </description>
    </item>
    
    <item>
      <title>org-mode规划笔记</title>
      <link>https://blog.linyxus.xyz/posts/introducing-org-templetes/</link>
      <pubDate>Wed, 13 Feb 2019 12:05:39 +0800</pubDate>
      
      <guid>https://blog.linyxus.xyz/posts/introducing-org-templetes/</guid>
      <description>org-mode可能是Emacs最有名的一部分。作为一个瑞士军刀般的笔记系统，org-mode真的可以渗入你生活的每个角落。
之前我也在学校社团里做过一个有关org-mode的讲座。关于org-mode，记忆深刻的是某知乎用户的一句话：
 我的生活就是在org-mode掌控之下的好吗
 那么，直接给出我使用org-mode的一些规划和设计吧。
.org&amp;nbsp;¶ gtd.org&amp;nbsp;¶ 在这个文件里放入日常事务，要完成的事情。
比如：打印四级准考证、整理行李、去开会、做推送等等。
idea.org&amp;nbsp;¶ 冒出来的想法，但不一定要实现。如果要实现，归档到gtd.org中完成。
比如：写一篇博客介绍我的org-mode使用方法、用Clojure写一个小游戏等等。
learning.org&amp;nbsp;¶ 学习规划。
比如学习Python，学习Haskell，学习各种算法等等。
book.org&amp;nbsp;¶ 书籍归档。
project-specific org file&amp;nbsp;¶ 各个project专用的.org文件，放在project根目录内。
Capture templates&amp;nbsp;¶ journal&amp;nbsp;¶ 小总结，小感想。
总结今天做了什么。（对抗焦虑症）
todo&amp;nbsp;¶ 要做的事情。
idea&amp;nbsp;¶ 突然冒出来的想法。
Source code&amp;nbsp;¶ 列一下org template配置的elisp代码：
(setq org-capture-templates &amp;#39;((&amp;#34;j&amp;#34; &amp;#34;journal&amp;#34; entry (file+datetree &amp;#34;~/org/journal.org&amp;#34;) &amp;#34;* %?\n%U\n&amp;#34;) (&amp;#34;t&amp;#34; &amp;#34;todo&amp;#34; entry (file+headline &amp;#34;~/org/gtd.org&amp;#34; &amp;#34;Inbox&amp;#34;) &amp;#34;* TODO %?\n%U\n&amp;#34;) (&amp;#34;i&amp;#34; &amp;#34;idea&amp;#34; entry (file+headline &amp;#34;~/org/idea.org&amp;#34; &amp;#34;Inbox&amp;#34;) &amp;#34;* TODO %?\n&amp;#34;))) </description>
    </item>
    
    <item>
      <title>「算法笔记」欧拉函数、欧拉定理与欧拉降幂公式</title>
      <link>https://blog.linyxus.xyz/posts/eular-formula/</link>
      <pubDate>Wed, 30 Jan 2019 19:29:20 +0800</pubDate>
      
      <guid>https://blog.linyxus.xyz/posts/eular-formula/</guid>
      <description>一些算法题里要求一个数的幂次，一般来说可以大整数+快速幂解决。但有时候数据真的很大，纵是快速幂也奈何不了这道题的。比如某道题要求$2^n$，$n \leq 10^{100000} $，十有八九会TLE。
大多数情况下，这么大的数据都会要求在某个数（通常是$10^9+7$）的模意义下输出答案。事实上，在这样的条件下，题目的用意是使用欧拉降幂公式先降低指数，然后再快速幂求解。
欧拉降幂公式&amp;nbsp;¶ 定理&amp;nbsp;¶ $$ a^p \equiv a^{p \bmod \phi(m) + \phi(m)} \pmod m $$
由于应用为主，证明从略。但显见上式等价于 $$ a^{2\phi(m)} \equiv a^{\phi(m)} \pmod m $$ 其中，$\phi(m)$为欧拉函数。
应用&amp;nbsp;¶ 所以，如果题设要求我们求出$a^p$在模$m$意义下的值，当$p$很大的时候，我们只需先求出$\phi(m)$，然后用快速幂求出$a^{p \bmod \phi(m)}$即可。
下面，假定$m=10^9+7$。
那么，下面的任务就是求出$\phi(m)$。
欧拉函数&amp;nbsp;¶ 对$\forall n \in N^*$，欧拉函数$\phi(n)$的值为小于$n$的正整数中与$n$互质的数的数目。
而欧拉函数存在解析式： $$ \phi(n) = n \prod_{p}(1 - \frac 1 p) $$ 其中，$p$为$n$的质因子。
证明从略，会用就行。
但还是简单说一说，显然有： $$ \phi(p^k) = p^k - p ^ {k-1} $$ 其中，$p$为素数。因为$p^k$与所有除$p$的倍数之外的数都互质。故只需从总数中减去$p$的倍数的个数即可。
而由中国剩余定理又可证出： $$ \phi(ab) = \phi(a)\phi(b) $$ 对$n$进行素因子分解即可。
所以，可以这样实现欧拉函数：</description>
    </item>
    
    <item>
      <title>「算法笔记」基础排序算法</title>
      <link>https://blog.linyxus.xyz/posts/sorting-algorithms/</link>
      <pubDate>Sat, 26 Jan 2019 22:19:46 +0800</pubDate>
      
      <guid>https://blog.linyxus.xyz/posts/sorting-algorithms/</guid>
      <description>这是这个冬天算法学习留下的第一篇笔记。
排序算法，是最基础的算法之一了吧。两年前或是三年前，我大概也是这样慢慢熟悉了他们。
算法是不会变的。
那么，就从这里开始吧。
插入排序&amp;nbsp;¶ 插入排序算不上高效的排序算法，从时间复杂度来说，和冒泡排序是相抵的。其实本质上，插入排序和冒泡排序相似甚至相同，只是“冒泡”的方向不同。
void insert_sort() { for (int i = 1; i &amp;lt; n; i++) { for (int j = i; j &amp;gt; 0; j--) { if (arr[j] &amp;lt; arr[j-1]) { int temp = arr[j]; arr[j] = arr[j-1]; arr[j-1] = temp; } } } return; } 在算法实现insert_sort执行的过程中，有这件事情得以保证：0..i-1这些元素已经排好序。
而关于变量j的那个循环，所做的事情就是“冒泡”，而这里的冒泡本质上也就是插入。
时间复杂度为$O(n^2)​$。
归并排序&amp;nbsp;¶ 归并排序是利用了分治思想的排序算法。
 分解问题：将要排序的数组分成两部分，将两部分分别排序。 合并：将两部分合并。  void merge_sort(int *begin, int *end) { int l = end - begin; if (l == 0 || l == 1) { return; } int m = l / 2; merge_sort(begin, begin+m); merge_sort(begin+m, end); int p = 0; int q = m; int cnt = 0; while (p &amp;lt; m || q &amp;lt; l) { if (q &amp;gt;= l || (p &amp;lt; m &amp;amp;&amp;amp; *(begin+p) &amp;lt;= *(begin+q))) { tmp[cnt++] = *(begin+p); p++; } else { tmp[cnt++] = *(begin+q); q++; } } for (int i = 0; i &amp;lt; l; i++) { *(begin+i) = tmp[i]; } } 分解问题无甚好说，重要的在于合并。</description>
    </item>
    
  </channel>
</rss>
