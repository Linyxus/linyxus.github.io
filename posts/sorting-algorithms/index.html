<!DOCTYPE html>
<html>

<head>
    
    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="chrome=1">
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="referrer" content="no-referrer">

<meta name="description" content="Linro :: blog of Linyxus">
<title>
    「算法笔记」基础排序算法 - Linro
</title>









<link rel="stylesheet" href="/css/main.min.8022aa4b53ce57ff6f9cc4594360bfc15f2baeb5a018d0c68826f12da49a51e0.css" integrity="sha256-gCKqS1POV/9vnMRZQ2C/wV8rrrWgGNDGiCbxLaSaUeA=" crossorigin="anonymous" media="screen">




  






<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Didact+Gothic">

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="「算法笔记」基础排序算法"/>
<meta name="twitter:description" content="这是这个冬天算法学习留下的第一篇笔记。
排序算法，是最基础的算法之一了吧。两年前或是三年前，我大概也是这样慢慢熟悉了他们。
算法是不会变的。
那么，就从这里开始吧。
插入排序&nbsp;¶ 插入排序算不上高效的排序算法，从时间复杂度来说，和冒泡排序是相抵的。其实本质上，插入排序和冒泡排序相似甚至相同，只是“冒泡”的方向不同。
void insert_sort() { for (int i = 1; i &lt; n; i&#43;&#43;) { for (int j = i; j &gt; 0; j--) { if (arr[j] &lt; arr[j-1]) { int temp = arr[j]; arr[j] = arr[j-1]; arr[j-1] = temp; } } } return; } 在算法实现insert_sort执行的过程中，有这件事情得以保证：0..i-1这些元素已经排好序。
而关于变量j的那个循环，所做的事情就是“冒泡”，而这里的冒泡本质上也就是插入。
时间复杂度为$O(n^2)​$。
归并排序&nbsp;¶ 归并排序是利用了分治思想的排序算法。
 分解问题：将要排序的数组分成两部分，将两部分分别排序。 合并：将两部分合并。  void merge_sort(int *begin, int *end) { int l = end - begin; if (l == 0 || l == 1) { return; } int m = l / 2; merge_sort(begin, begin&#43;m); merge_sort(begin&#43;m, end); int p = 0; int q = m; int cnt = 0; while (p &lt; m || q &lt; l) { if (q &gt;= l || (p &lt; m &amp;&amp; *(begin&#43;p) &lt;= *(begin&#43;q))) { tmp[cnt&#43;&#43;] = *(begin&#43;p); p&#43;&#43;; } else { tmp[cnt&#43;&#43;] = *(begin&#43;q); q&#43;&#43;; } } for (int i = 0; i &lt; l; i&#43;&#43;) { *(begin&#43;i) = tmp[i]; } } 分解问题无甚好说，重要的在于合并。"/>

<meta property="og:title" content="「算法笔记」基础排序算法" />
<meta property="og:description" content="这是这个冬天算法学习留下的第一篇笔记。
排序算法，是最基础的算法之一了吧。两年前或是三年前，我大概也是这样慢慢熟悉了他们。
算法是不会变的。
那么，就从这里开始吧。
插入排序&nbsp;¶ 插入排序算不上高效的排序算法，从时间复杂度来说，和冒泡排序是相抵的。其实本质上，插入排序和冒泡排序相似甚至相同，只是“冒泡”的方向不同。
void insert_sort() { for (int i = 1; i &lt; n; i&#43;&#43;) { for (int j = i; j &gt; 0; j--) { if (arr[j] &lt; arr[j-1]) { int temp = arr[j]; arr[j] = arr[j-1]; arr[j-1] = temp; } } } return; } 在算法实现insert_sort执行的过程中，有这件事情得以保证：0..i-1这些元素已经排好序。
而关于变量j的那个循环，所做的事情就是“冒泡”，而这里的冒泡本质上也就是插入。
时间复杂度为$O(n^2)​$。
归并排序&nbsp;¶ 归并排序是利用了分治思想的排序算法。
 分解问题：将要排序的数组分成两部分，将两部分分别排序。 合并：将两部分合并。  void merge_sort(int *begin, int *end) { int l = end - begin; if (l == 0 || l == 1) { return; } int m = l / 2; merge_sort(begin, begin&#43;m); merge_sort(begin&#43;m, end); int p = 0; int q = m; int cnt = 0; while (p &lt; m || q &lt; l) { if (q &gt;= l || (p &lt; m &amp;&amp; *(begin&#43;p) &lt;= *(begin&#43;q))) { tmp[cnt&#43;&#43;] = *(begin&#43;p); p&#43;&#43;; } else { tmp[cnt&#43;&#43;] = *(begin&#43;q); q&#43;&#43;; } } for (int i = 0; i &lt; l; i&#43;&#43;) { *(begin&#43;i) = tmp[i]; } } 分解问题无甚好说，重要的在于合并。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://blog.linyxus.xyz/posts/sorting-algorithms/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-01-26T22:19:46&#43;08:00" />
<meta property="article:modified_time" content="2019-01-26T22:19:46&#43;08:00" />



    

    
    
    
    <title>
        
        「算法笔记」基础排序算法
        
    </title>
</head>

<body>
    
    
    <header class="wrap flex-container">
        <h1>「算法笔记」基础排序算法</h1>
    </header>
    
    <main class="wrap">
        
<div class="flex-container">
    <aside role="complementary">
        Sat Jan 26, 2019 &#183; 239 words
        <div class="tag-container">
            
            
            <span class="tag">
                <a href="/tags/algorithm/">
                    algorithm
                </a>
            </span>
            
            
            
            <span class="tag">
                <a href="/tags/note/">
                    note
                </a>
            </span>
            
            
        </div>
    </aside>
    <hr />
    <article role="article">
        <p>这是这个冬天算法学习留下的第一篇笔记。</p>
<p>排序算法，是最基础的算法之一了吧。两年前或是三年前，我大概也是这样慢慢熟悉了他们。</p>
<p>算法是不会变的。</p>
<p>那么，就从这里开始吧。</p>

<h2 id="插入排序" class="anchor-link"><a href="#%e6%8f%92%e5%85%a5%e6%8e%92%e5%ba%8f">插入排序<span class="pilcrow">&nbsp;¶</span></a></h2>
<p>插入排序算不上高效的排序算法，从时间复杂度来说，和冒泡排序是相抵的。其实本质上，插入排序和冒泡排序相似甚至相同，只是“冒泡”的方向不同。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">insert_sort</span>()
{
  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>) {
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> i; j <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>; j<span style="color:#f92672">--</span>) {
      <span style="color:#66d9ef">if</span> (arr[j] <span style="color:#f92672">&lt;</span> arr[j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]) {
        <span style="color:#66d9ef">int</span> temp <span style="color:#f92672">=</span> arr[j];
        arr[j] <span style="color:#f92672">=</span> arr[j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>];
        arr[j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> temp;
      }
    }
  }
  <span style="color:#66d9ef">return</span>;
}
</code></pre></div><p>在算法实现<code>insert_sort</code>执行的过程中，有这件事情得以保证：0..i-1这些元素已经排好序。</p>
<p>而关于变量<code>j</code>的那个循环，所做的事情就是“冒泡”，而这里的冒泡本质上也就是插入。</p>
<p>时间复杂度为$O(n^2)​$。</p>

<h2 id="归并排序" class="anchor-link"><a href="#%e5%bd%92%e5%b9%b6%e6%8e%92%e5%ba%8f">归并排序<span class="pilcrow">&nbsp;¶</span></a></h2>
<p>归并排序是利用了分治思想的排序算法。</p>
<ul>
<li>分解问题：将要排序的数组分成两部分，将两部分分别排序。</li>
<li>合并：将两部分合并。</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">merge_sort</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>begin, <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>end)
{
  <span style="color:#66d9ef">int</span> l <span style="color:#f92672">=</span> end <span style="color:#f92672">-</span> begin;
  <span style="color:#66d9ef">if</span> (l <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> l <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>) {
    <span style="color:#66d9ef">return</span>;
  }
  <span style="color:#66d9ef">int</span> m <span style="color:#f92672">=</span> l <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>;
  merge_sort(begin, begin<span style="color:#f92672">+</span>m);
  merge_sort(begin<span style="color:#f92672">+</span>m, end);
  <span style="color:#66d9ef">int</span> p <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
  <span style="color:#66d9ef">int</span> q <span style="color:#f92672">=</span> m;
  <span style="color:#66d9ef">int</span> cnt <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
  <span style="color:#66d9ef">while</span> (p <span style="color:#f92672">&lt;</span> m <span style="color:#f92672">||</span> q <span style="color:#f92672">&lt;</span> l) {
    <span style="color:#66d9ef">if</span> (q <span style="color:#f92672">&gt;=</span> l <span style="color:#f92672">||</span> (p <span style="color:#f92672">&lt;</span> m <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">*</span>(begin<span style="color:#f92672">+</span>p) <span style="color:#f92672">&lt;=</span> <span style="color:#f92672">*</span>(begin<span style="color:#f92672">+</span>q))) {
      tmp[cnt<span style="color:#f92672">++</span>] <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>(begin<span style="color:#f92672">+</span>p);
      p<span style="color:#f92672">++</span>;
    } <span style="color:#66d9ef">else</span> {
      tmp[cnt<span style="color:#f92672">++</span>] <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>(begin<span style="color:#f92672">+</span>q);
      q<span style="color:#f92672">++</span>;
    }
  }
  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> l; i<span style="color:#f92672">++</span>) {
    <span style="color:#f92672">*</span>(begin<span style="color:#f92672">+</span>i) <span style="color:#f92672">=</span> tmp[i];
  }
}
</code></pre></div><p>分解问题无甚好说，重要的在于合并。</p>
<p>合并的思想有个很棒的类比：你有两堆牌，它们都是排好序的，将它们合并成一堆排好序的牌的方法是比较它们最上面的那张牌，将更小的放入合并的牌堆。当某一堆牌放完，直接把另一堆牌全部放入合并的牌堆即可。</p>
<p>这里用到了临时的额外空间。</p>
<p>时间复杂度为$O(nlogn)$。</p>

<h2 id="快速排序" class="anchor-link"><a href="#%e5%bf%ab%e9%80%9f%e6%8e%92%e5%ba%8f">快速排序<span class="pilcrow">&nbsp;¶</span></a></h2>
<p>快速排序也是利用了分治思想的排序算法。只是求解问题的方法与归并排序有所不同。</p>
<ul>
<li>分解问题：将数组分成两个部分，满足：左半部分任意一个数都小于等于右半部分。再将这两个部分划分，直到不能再划分。</li>
<li>合并：不必合并，此时数组已有序。</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">quick_sort</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>begin, <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>end)
{
  <span style="color:#66d9ef">if</span> (begin <span style="color:#f92672">==</span> end) {
    <span style="color:#66d9ef">return</span>;
  }
  <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>l <span style="color:#f92672">=</span> begin;
  <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>r <span style="color:#f92672">=</span> end<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
  <span style="color:#66d9ef">int</span> t <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>l;
  <span style="color:#66d9ef">while</span> (l <span style="color:#f92672">&lt;</span> r) {
    <span style="color:#66d9ef">while</span> (l <span style="color:#f92672">&lt;</span> r <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">*</span>r <span style="color:#f92672">&gt;=</span> t) {
      r<span style="color:#f92672">--</span>;
    }
    <span style="color:#f92672">*</span>l <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>r;
    <span style="color:#66d9ef">while</span> (l <span style="color:#f92672">&lt;</span> r <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">*</span>l <span style="color:#f92672">&lt;=</span> t) {
      l<span style="color:#f92672">++</span>;
    }
    <span style="color:#f92672">*</span>r <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>l;
  }
  <span style="color:#f92672">*</span>l <span style="color:#f92672">=</span> t;
  quick_sort(begin, l);
  quick_sort(l<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, end);
}
</code></pre></div><p>快速排序实现的关键在于划分的方法。上面这个方法算得上主流的一个，不必额外空间，可以理解成一次长长的交换。</p>
<p>在循环的过程中，这些事情得以保证：</p>
<ol>
<li>无论何时，都有一个空位可以放入数字。</li>
<li>循环开始时，这个空位是<code>l</code>。</li>
<li>空位在<code>l</code>和<code>r</code>之间轮换。</li>
<li>递减<code>r</code>时，<code>l</code>总是空位，反之亦然。</li>
<li>赋值操作事实上完成了空位的轮换。</li>
<li>begin…l之间的数都小于等于t</li>
<li>r…end-1之间的数都大于等于t</li>
</ol>
<p>值得一提的是，如此实现的快速排序是不稳定的。</p>
<p>快速排序的时间复杂度在最好情况下是$O(nlogn)$，最坏情况下与插入排序及冒泡排序比肩，到达$O(n^2)$。</p>
<p>但大多数情况下，快速排序的效率远高于插入排序，也快于归并排序。</p>
<p>第一篇笔记，就写到这里。</p>

    </article>
</div>


        
<nav role="navigation" class="flex-container bottom-menu">
    
<hr />
<p>


    
        <a href="/posts">back</a>
        
            &#183;
        
    

    
        
            <a href="/posts">writings</a>
        
    
    
        
            &#183; 
            <a href="/me">me</a>
        
            &#183; 
            <a href="/about">about</a>
        
    
    
    
        &#183; 
        <a href="/">
            main
        </a>
    

</p>
</nav>

    </main>
    
    <footer class="flex-container footer"><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        displayMath: [['$$','$$'], ['\[','\]']],
        processEscapes: true,
        processEnvironments: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
        TeX: { equationNumbers: { autoNumber: "AMS" },
             extensions: ["AMSmath.js", "AMSsymbols.js"] }
      }
    });
</script>
<link rel="stylesheet" href="https://blog.linyxus.xyz/css/syntax.css">
</footer>
    
    
</body>

</html>