<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>writings on Linro</title>
    <link>https://linyxus.github.io/posts/</link>
    <description>Recent content in writings on Linro</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Tue, 22 Jan 2019 19:47:50 +0800</lastBuildDate>
    
	<atom:link href="https://linyxus.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>让Hugo和reStucturedText和睦相处</title>
      <link>https://linyxus.github.io/posts/use-rst-with-hugo/</link>
      <pubDate>Thu, 04 Apr 2019 20:37:33 +0800</pubDate>
      
      <guid>https://linyxus.github.io/posts/use-rst-with-hugo/</guid>
      <description>起因 在写完 这一篇博客 之后，我对Markdown彻底失望了， 尽管它有可爱的Typora和GFM，尽管我已用它写下了无数篇博客。  没错，还是数学公式渲染问题。  Markdown和LaTeX似乎总是两对冤家，因为Markdown滥用的 _ 语法，并且并没有原生的数学公式支持，大部分 Markdown编译器永远无法完善的解决下标和斜体的恩怨情仇。  Hugo家的BlackFriday，也不例外。  我曾在 这篇博客 中自信的以为Hugo官方给出 的Workaround并无必要，天真的以为Hugo的Markdown编译器不存在这样的问题。现在，我知道我错了。  在之前提到的，一篇数学笔记博客中，下面的LaTeX代码在渲染时还是中了 &amp;lt;em&amp;gt; 的枪。  1 $$2 \lim_{k \to+\infty} X_k =A \Leftrightarrow\lim_{k \to+\infty} x_k^{(i)} =a(i), i=1,2,…,n. 3 $$  所以，我打算转移到更健全的rST。至少rST有专门的Math模块，比如上面出错的LaTeX代码在rST中可以毫无问题的展现：  \begin{equation*} \lim_{k \to +\infty} X_k = A \Leftrightarrow \lim_{k \to +\infty} x_k^{(i)} = a(i), i=1,2,\ldots ,n. \end{equation*}  和Markdown相比，rST几乎没有什么弱点。Markdown能做到的事情，rST也无所不能。而很多能力，例如完备无冲突的公式 显示，是过于单薄的Markdown无法企及的。  很幸运的，虽然Hugo内置支持的是Markdown， 但是也能通过调用外部程序支持rST 。 但毕竟rST不是亲儿子，一开始还是会有些小问题：   小问题 LaTeX显示 因为 rst2html 对于数学文本块默认是会进行编译的，转成pdf倒还好，但如果转成HTML，显示的效果就非常难看 （众所周知，HTML对公式的支持非常差）。所以这种任务还是交给MathJax为好，需要修改docutils的配置文件：  1 [html4css1 writer] 2 math-output: mathjax 3  https://cdnjs.</description>
    </item>
    
    <item>
      <title>微积分笔记 #1 :: 多元微积分初步</title>
      <link>https://linyxus.github.io/posts/caculas-1/</link>
      <pubDate>Mon, 01 Apr 2019 16:28:15 +0800</pubDate>
      
      <guid>https://linyxus.github.io/posts/caculas-1/</guid>
      <description>n-dimension Euclid Space $R^n$ 邻域 $$ X_0点的\delta邻域：B(X_0, \delta) = {X \in R^n : ||X-X_0&amp;lt;\delta||} $$
$$ X_0点的去心\delta邻域：B(X_0, \delta) = {X \in R^n : 0 &amp;lt; ||X-X_0|| &amp;lt; \delta} $$
点与集 内点： $$ I(x) : x为\Omega的内点 $$
$$ I(x) \Leftrightarrow \exists \delta &amp;gt; 0, B(x,\delta) \subset \Omega $$
边界点： $$ S(x) \Leftrightarrow \forall \delta &amp;gt; 0 (B(x,\delta) \cap \Omega \neq \emptyset \wedge B(x,\delta) \cap R^n /\Omega \neq \emptyset) $$ 说明点$x$的任意一个邻域都横跨了集合$\Omega$的边界，很漂亮的定义。</description>
    </item>
    
    <item>
      <title>利用cron自动同步org到Github</title>
      <link>https://linyxus.github.io/posts/sync-org-files/</link>
      <pubDate>Tue, 26 Feb 2019 22:58:41 +0800</pubDate>
      
      <guid>https://linyxus.github.io/posts/sync-org-files/</guid>
      <description> 效果   每天在固定的时间，只要电脑开着，自动commit发生在org文件夹内的改动，并且push到Github上。
如图，设定的是在所有的整点都会自动更新。
步骤 #1 编写自动同步shell #!/bin/bash  echo -e &amp;#34;\033[0;32mPulling from GitHub...\033[0m&amp;#34; git pull git add . git commit -m &amp;#34;Auto update : `date`&amp;#34; echo -e &amp;#34;\033[0;32mPushing to GitHub...\033[0m&amp;#34; git push origin master 在echo的文本里奇奇怪怪的内容都是escape characters，目的是更更改文本的颜色（为绿色）。目的是看起来更加舒服。（可是自动运行的时候你根本看不见啊喂）
#2 增加cron task 在命令行中输入：
$ EDITOR=nano cron -e 增加这一行：
0 * * * * cd ~/org &amp;amp;&amp;amp; ./update.sh 保存退出即可。
 注意！注意！注意！
macOS下由于一些奇怪的权限原因，只能使用Terminal.app进行编辑。
iTerm2是不行的。
 #3 Enjoy it! </description>
    </item>
    
    <item>
      <title>org-mode规划笔记</title>
      <link>https://linyxus.github.io/posts/introducing-org-templetes/</link>
      <pubDate>Wed, 13 Feb 2019 12:05:39 +0800</pubDate>
      
      <guid>https://linyxus.github.io/posts/introducing-org-templetes/</guid>
      <description>org-mode可能是Emacs最有名的一部分。作为一个瑞士军刀般的笔记系统，org-mode真的可以渗入你生活的每个角落。
之前我也在学校社团里做过一个有关org-mode的讲座。关于org-mode，记忆深刻的是某知乎用户的一句话：
 我的生活就是在org-mode掌控之下的好吗
 那么，直接给出我使用org-mode的一些规划和设计吧。
.org gtd.org 在这个文件里放入日常事务，要完成的事情。
比如：打印四级准考证、整理行李、去开会、做推送等等。
idea.org 冒出来的想法，但不一定要实现。如果要实现，归档到gtd.org中完成。
比如：写一篇博客介绍我的org-mode使用方法、用Clojure写一个小游戏等等。
learning.org 学习规划。
比如学习Python，学习Haskell，学习各种算法等等。
book.org 书籍归档。
project-specific org file 各个project专用的.org文件，放在project根目录内。
Capture templates journal 小总结，小感想。
总结今天做了什么。（对抗焦虑症）
todo 要做的事情。
idea 突然冒出来的想法。
Source code 列一下org template配置的elisp代码：
(setq org-capture-templates &amp;#39;((&amp;#34;j&amp;#34; &amp;#34;journal&amp;#34; entry (file+datetree &amp;#34;~/org/journal.org&amp;#34;) &amp;#34;* %?\n%U\n&amp;#34;) (&amp;#34;t&amp;#34; &amp;#34;todo&amp;#34; entry (file+headline &amp;#34;~/org/gtd.org&amp;#34; &amp;#34;Inbox&amp;#34;) &amp;#34;* TODO %?\n%U\n&amp;#34;) (&amp;#34;i&amp;#34; &amp;#34;idea&amp;#34; entry (file+headline &amp;#34;~/org/idea.org&amp;#34; &amp;#34;Inbox&amp;#34;) &amp;#34;* TODO %?</description>
    </item>
    
    <item>
      <title>Dozer: 用两个小点管理你的macOS状态栏</title>
      <link>https://linyxus.github.io/posts/introduction-to-dozer/</link>
      <pubDate>Mon, 11 Feb 2019 13:20:02 +0800</pubDate>
      
      <guid>https://linyxus.github.io/posts/introduction-to-dozer/</guid>
      <description>macOS的状态栏设计是个饱受诟病的地方。因为从系统层面上，并不存在管理状态栏的功能（除了排序）。
  由于没有隐藏图标的功能，所以很多从来用不着也不想看的图标总是占着位置。比如Spotlight的放大镜，比如Siri的圆圈。
对于这个问题有不少流行的解决方案，Bartender是主流，也有Vanilla之流紧随其后。
  只是光是Bartender丑丑的icon就让人望而却步，Vanilla虽然icon尚算得上好看，但是它隐藏状态栏图标的实现非常丑陋，似乎是用一个窗口遮盖，这种连hack都是抬举的实现办法带来三个问题：
 由于不同应用程序的菜单栏长度不同，切换应用程序后遮盖菜单栏是家常便饭 切换到Mission Control时用于遮盖的窗口会原形毕露 变色壁纸变色时遮盖窗口来不及变色  而最重要的是，这两个家伙都要钱，价钱算不上贵，但由于他们一个长得丑，一个缺胳膊少腿，为了这种货色花钱心里总不那么舒服。
当然，也可以去一些网站上找hack过的免费解锁版本，这也是种选择。
但前些日子，我在万能的知乎上找到了几乎无可挑剔的另一个选择：
Dozer Dozer是完全开源的，Github主页在此。
具体的安装&amp;amp;使用方法在Github上都有，这里小小一提：
Install brew cask install dozer  Usage 略
Github上的演示：</description>
    </item>
    
    <item>
      <title>「算法笔记」欧拉函数、欧拉定理与欧拉降幂公式</title>
      <link>https://linyxus.github.io/posts/eular-formula/</link>
      <pubDate>Wed, 30 Jan 2019 19:29:20 +0800</pubDate>
      
      <guid>https://linyxus.github.io/posts/eular-formula/</guid>
      <description>一些算法题里要求一个数的幂次，一般来说可以大整数+快速幂解决。但有时候数据真的很大，纵是快速幂也奈何不了这道题的。比如某道题要求$2^n$，$n \leq 10^{100000} $，十有八九会TLE。
大多数情况下，这么大的数据都会要求在某个数（通常是$10^9+7$）的模意义下输出答案。事实上，在这样的条件下，题目的用意是使用欧拉降幂公式先降低指数，然后再快速幂求解。
欧拉降幂公式 定理 $$ a^p \equiv a^{p \bmod \phi(m) + \phi(m)} \pmod m $$
由于应用为主，证明从略。但显见上式等价于 $$ a^{2\phi(m)} \equiv a^{\phi(m)} \pmod m $$ 其中，$\phi(m)$为欧拉函数。
应用 所以，如果题设要求我们求出$a^p$在模$m$意义下的值，当$p$很大的时候，我们只需先求出$\phi(m)$，然后用快速幂求出$a^{p \bmod \phi(m)}$即可。
下面，假定$m=10^9+7$。
那么，下面的任务就是求出$\phi(m)$。
欧拉函数 对$\forall n \in N^*$，欧拉函数$\phi(n)$的值为小于$n$的正整数中与$n$互质的数的数目。
而欧拉函数存在解析式： $$ \phi(n) = n \prod_{p}(1 - \frac 1 p) $$ 其中，$p$为$n$的质因子。
证明从略，会用就行。
但还是简单说一说，显然有： $$ \phi(p^k) = p^k - p ^ {k-1} $$ 其中，$p$为素数。因为$p^k$与所有除$p$的倍数之外的数都互质。故只需从总数中减去$p$的倍数的个数即可。
而由中国剩余定理又可证出： $$ \phi(ab) = \phi(a)\phi(b) $$ 对$n$进行素因子分解即可。</description>
    </item>
    
    <item>
      <title>Hugo &amp; Mathjax</title>
      <link>https://linyxus.github.io/posts/hugo-and-mathjax/</link>
      <pubDate>Tue, 29 Jan 2019 22:07:57 +0800</pubDate>
      
      <guid>https://linyxus.github.io/posts/hugo-and-mathjax/</guid>
      <description>&lt;p&gt;Mathjax是什么就不多说了，$\LaTeX$公式网页渲染最常用的lib。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>「算法笔记」基础排序算法</title>
      <link>https://linyxus.github.io/posts/sorting-algorithms/</link>
      <pubDate>Sat, 26 Jan 2019 22:19:46 +0800</pubDate>
      
      <guid>https://linyxus.github.io/posts/sorting-algorithms/</guid>
      <description>这是这个冬天算法学习留下的第一篇笔记。
排序算法，是最基础的算法之一了吧。两年前或是三年前，我大概也是这样慢慢熟悉了他们。
算法是不会变的。
那么，就从这里开始吧。
插入排序 插入排序算不上高效的排序算法，从时间复杂度来说，和冒泡排序是相抵的。其实本质上，插入排序和冒泡排序相似甚至相同，只是“冒泡”的方向不同。
void insert_sort() { for (int i = 1; i &amp;lt; n; i++) { for (int j = i; j &amp;gt; 0; j--) { if (arr[j] &amp;lt; arr[j-1]) { int temp = arr[j]; arr[j] = arr[j-1]; arr[j-1] = temp; } } } return; }  在算法实现insert_sort执行的过程中，有这件事情得以保证：0..i-1这些元素已经排好序。
而关于变量j的那个循环，所做的事情就是“冒泡”，而这里的冒泡本质上也就是插入。
时间复杂度为$O(n^2)​$。
归并排序 归并排序是利用了分治思想的排序算法。
 分解问题：将要排序的数组分成两部分，将两部分分别排序。 合并：将两部分合并。  void merge_sort(int *begin, int *end) { int l = end - begin; if (l == 0 || l == 1) { return; } int m = l / 2; merge_sort(begin, begin+m); merge_sort(begin+m, end); int p = 0; int q = m; int cnt = 0; while (p &amp;lt; m || q &amp;lt; l) { if (q &amp;gt;= l || (p &amp;lt; m &amp;amp;&amp;amp; *(begin+p) &amp;lt;= *(begin+q))) { tmp[cnt++] = *(begin+p); p++; } else { tmp[cnt++] = *(begin+q); q++; } } for (int i = 0; i &amp;lt; l; i++) { *(begin+i) = tmp[i]; } }  分解问题无甚好说，重要的在于合并。</description>
    </item>
    
    <item>
      <title>Algorithm Learning Roadmap</title>
      <link>https://linyxus.github.io/posts/algorithm-roadmap/</link>
      <pubDate>Fri, 25 Jan 2019 19:38:20 +0800</pubDate>
      
      <guid>https://linyxus.github.io/posts/algorithm-roadmap/</guid>
      <description> 基础  排序  插入排序 归并排序 桶排序 希尔排序 快速排序  搜索  BFS DFS 回溯 迭代加深搜索 A*  暴力枚举 图  DFS BFS 拓扑排序 欧拉回路  二叉树 分而治之 贪心 动态规划  高级  数论 图论 线段树 组合数学  训练路线  重温紫书及配套练习。配合luogu刷题。 进军黑书。 进军训练指南。  </description>
    </item>
    
    <item>
      <title>Hello, Hugo</title>
      <link>https://linyxus.github.io/posts/hello/</link>
      <pubDate>Wed, 23 Jan 2019 19:44:21 +0800</pubDate>
      
      <guid>https://linyxus.github.io/posts/hello/</guid>
      <description>&lt;p&gt;2019年1月，我重拾博客。&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>